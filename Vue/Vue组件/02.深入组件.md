# 一、父组件与子组件通信：`props`属性

父组件向子组件通信的形式：

+ 传递静态prop：

```html
<!--传递静态prop-->
<father-component my-name="peanut"></father-component>

<!-- 子组件中通过下面的形式接收prop -->
<script>
	export default {
    name: 'SonComponent',
    props: ['myName']
  }
</script>
```

+ 传递动态prop：使用`v-bind`指令在父组件根元素上绑定该属性的属性值；

```html
<!--传递静态prop-->
<father-component :my-name="peanut"></father-component>

<!-- 子组件中通过下面的形式接收prop -->
<script>
	export default {
    name: 'SonComponent',
    props: ['myName']
  }
</script>
```

------

## 1.prop的大小写

分为两种情况：

1. `template`使用字符串形式指定：`注册时驼峰命名的prop，在html父组件上传值时需要用短横线隔开`；
2. `template`使用模板字符串指定：`可以使用驼峰命名`；

------

## 2.prop类型

### 数组形式

```js
// 子组件中
<script>
	export default {
    name: 'SonComponent',
    props: ['myName','myAge'...]
  }
</script>
```

### 对象形式

+ 使用对象形式，可以在接收prop时指定每个prop的property名称和需要接收的值类型；

```js
// 子组件中
<script>
	export default {
    name: 'SonComponent',
    props: {
      myName: String,
      myAge: Number
      ...
    }
  }
</script>
```

对象形式的prop指定了给property传递的值类型必须是指定的类型，否则会抛出错误；

------

## 3.动态传值

+ 将要传递的property通过`v-bind`绑定即可实现动态传值；

### 传入一个对象所有属性

实际开发中可能我们只需要传递某个对象中的某一个属性，但是有时候也可能需要一次性将整个对象所有的property传递到子组件；

如下所示：

```html
<!-- 假设父组件需要传递如下的对象 -->
person{
	name: 'peanut',
	age: 18
}

<!-- 父组件 -->
<father :some-one="person"></father>
<!-- 等价于 -->
<father :name="person.name"></father>
<father :name="person.age"></father>

<!-- 子组件接收 -->
<script>
	export default {
    props: {
      someOne: Object
    }
  }
</script>
```

------

## 4.单向数据流

+ 父组件的prop更新会同步到子组件，反过来则不行；这样能防止子组件意外变更父组件的状态；
+ 父组件的prop只要发生更新都会更新一次子组件中对应的prop，因此，`不能在子组件中对prop的值进行修改，但是可以采用变通的方法`；

下面是两种比较常见的情况：

+ 子组件prop需要被作为子组件特有的数据使用：此时可以通过data将该prop单独存储，并使用该prop进行初始化；
+ 使用子组件prop前需要对其进行某些处理（比如trim）：此时可以通过计算属性进行处理，而不是直接操作props中的prop；

-----

## 5.prop验证

在接收prop的同时，可以在props中对prop进行类型检查，主要就是为prop提供一个包含类型检查需求的对象;

`null和undefined可以通过任何类型检查`；

具体看如下的代码演示：

```js
props: {
  // 最基础的类型检查
  propA: Number,
  
  // 多个可能的值类型 通过数组形式指定，数组内部就是可能的值类型
  propB: [Number,Object],
    
  // 这种形式用的比较多
  propC: {
    type: String,  // 也可以指定多个值类型[String,Array]
    default: 'test',// 指定默认值，在父组件未传递prop时生效
    required: true, // 值是Boolean，指定该prop是否是必须传值的
  },
    
  // Array、Object类型的默认值必须以工厂模式返回
  propD: {
    type: Array,
    default(){
      return []
    }
  }
}
```

### 类型检查

+ `type`：用于指定prop接收哪些类型的值；

+ type值可以是下面这些类型：

    + String
    + Number
    + Boolean
    + Object
    + Array
    + Date
    + Function
    + Symbol
    + validator(自定义验证函数)

    这里主要深入了解一下自定义验证函数，该自定义函数是一个构造函数，通过`instanceof`进行类型检查，检查prop值是否由该验证函数所创建；

```js
// 自定义验证函数
function Person(name,age){
  this.name = name;
  this.age = age;
}

// 子组件props
props: {
  name: {
    type: Person
  }
}
// 如果子组件名字为name的prop不是由Person创建的，就会抛出错误
```

------

## 6.关于父组件传递的attribute

+ 重复的attribute会被合并，而不是替换；
+ 父组件传递了，但是子组件没有对应的prop接收的attribute：
    + 可以通过实例的`$attrs属性`访问；



==禁用attribute继承==

+ `inheritAttrs属性`：属性值是布尔值，用于指定子组件的根元素是否要继承父组件的attribute；
+ 该属性值为false时，不影响class和style的绑定 ；

```js
Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
```

